# -*- coding: utf-8 -*-
"""tubes_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1miYaQAnjyjPvO9yi3mfEQTmxnArF2kPd
"""

# Analisis Gaji Profesi Data

import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# 1. Baca data
df = pd.read_csv("ds_salaries.csv")
print("Data contoh awal:")
print(df.head())

# --- Tambahan: Outlier Removal (konsisten dengan app.py untuk Random Forest) ---
df_rf_src = df.copy()
Q1_rf = df_rf_src['salary_in_usd'].quantile(0.25)
Q3_rf = df_rf_src['salary_in_usd'].quantile(0.75)
IQR_rf = Q3_rf - Q1_rf
batas_bawah_rf = Q1_rf - 1.5 * IQR_rf
batas_atas_rf = Q3_rf + 1.5 * IQR_rf
df_cleaned = df_rf_src[~((df_rf_src['salary_in_usd'] < batas_bawah_rf) | (df_rf_src['salary_in_usd'] > batas_atas_rf))]
print(f"\nJumlah data setelah outlier removal: {len(df_cleaned)} dari {len(df_rf_src)}")
# --- Akhir Tambahan Outlier Removal ---

# 2. persiapan data
# Buat data dummy untuk kolom kategori, TANPA 'employee_residence'
# Menggunakan df_cleaned sekarang
df_dummy = pd.get_dummies(df_cleaned, columns=['experience_level', 'employment_type', 'job_title', 'company_size'])

# Pilih fitur (X) dan target (y)
# 'employee_residence' tidak lagi di-dummy, jadi tidak akan ada di X jika tidak diproses secara manual
# Kolom yang di-drop juga disesuaikan
X = df_dummy.drop(['salary_in_usd', 'salary', 'salary_currency', 'company_location', 'employee_residence'], axis=1, errors='ignore')
y = df_dummy['salary_in_usd']

print("\nData dummy (setelah outlier removal & tanpa employee_residence_dummies):")
print(df_dummy.head())
print("\nFitur X yang digunakan (contoh):")
print(X.head())
print(f"Jumlah fitur X: {X.shape[1]}")

# 3. clustering pake KMeans berdasarkan salary dan remote_ratio (menggunakan df_dummy dari data yang sudah dibersihkan)
# Sebaiknya clustering dilakukan pada data yang relevan, mungkin sebelum atau sesudah outlier removal tergantung tujuan.
# Di sini kita gunakan df_dummy yang berasal dari df_cleaned.
data_cluster = df_dummy[['salary_in_usd', 'remote_ratio']]
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_cluster)

kmeans = KMeans(n_clusters=3, random_state=42, n_init='auto') # n_init='auto' untuk suppress warning
clusters = kmeans.fit_predict(data_scaled)

print("\nHasil Clustering (3 cluster):")
print(pd.Series(clusters).value_counts())

import matplotlib.pyplot as plt

plt.scatter(df_dummy['remote_ratio'], df_dummy['salary_in_usd'], c=clusters, cmap='viridis')
plt.xlabel('Remote Ratio (%)')
plt.ylabel('Salary in USD')
plt.title('Clustering Salary vs Remote Ratio (Data Setelah Outlier Removal)')
plt.colorbar(label='Cluster')
plt.show()

# 4. bagi data jadi train dan test untuk regresi
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 5. Latih model Random Forest
model = RandomForestRegressor(random_state=42) # Belum menggunakan parameter tuning dari app.py
model.fit(X_train, y_train)

# 6. Prediksi dan evaluasi
y_pred = model.predict(X_test)

print("\nEvaluasi Model (Setelah Outlier Removal & Modifikasi Fitur):")
print("MAE:", round(mean_absolute_error(y_test, y_pred), 2))
print("MSE:", round(mean_squared_error(y_test, y_pred), 2))
print("R2 Score:", round(r2_score(y_test, y_pred), 4))

"""
Model prediksi gaji yang dibangun menggunakan algoritma Random Forest Regressor, yaitu Mean Absolute Error (MAE), Mean Squared Error (MSE), dan R-squared (R² Score)

Mean Absolute Error (MAE) sebesar 6.775,4 USD menunjukkan bahwa rata-rata kesalahan prediksi antara nilai aktual dan nilai yang diprediksi oleh model adalah sekitar 6.775 dolar AS. Nilai MAE yang relatif kecil ini mengindikasikan bahwa model mampu memberikan prediksi yang cukup akurat secara umum

Mean Squared Error (MSE) sebesar 419.069.382,13 memberikan gambaran tentang seberapa besar error yang terjadi jika dikuadratkan. Karena MSE memberi penalti lebih besar terhadap kesalahan prediksi yang ekstrem, nilai ini masih tergolong wajar dan tidak menunjukkan adanya kesalahan prediksi yang terlalu besar

R² Score sebesar 0,8907 atau sekitar 89% berarti bahwa model mampu menjelaskan sekitar 89% variasi dalam data gaji berdasarkan fitur-fitur input yang digunakan. Ini menandakan bahwa model memiliki performa prediksi yang baik dan dapat diandalkan dalam memperkirakan gaji berdasarkan variabel-variabel seperti pengalaman kerja, jenis pekerjaan, lokasi, dan lainnya

Secara keseluruhan, ketiga metrik evaluasi ini menunjukkan bahwa model Random Forest Regressor yang digunakan bekerja dengan tingkat akurasi yang tinggi, serta mampu menangkap pola hubungan antara fitur dan target dengan cukup baik"""

# 7. contoh prediksi gaji baru
# data input (tanpa employee_residence_US)
input_data = {
    'work_year': 2022,
    'remote_ratio': 100,
    # dummy kolom yang penting di-set ke 1, sisanya 0
    'experience_level_SE': 1,
    'employment_type_FT': 1,
    # ambil salah satu job_title dummy yang ada (sesuaikan di dataset)
    'job_title_Data Scientist': 1,
    # 'employee_residence_US': 1, # Dihapus karena employee_residence tidak lagi jadi fitur dummy
    'company_size_M': 1
}

# Buat dataframe input yang sesuai kolom X
input_df = pd.DataFrame(columns=X.columns)
input_df.loc[0] = 0  # semua kolom default 0

for col_name_input, value_input in input_data.items(): # Mengganti nama variabel agar tidak bentrok
    if col_name_input in input_df.columns:
        input_df.at[0, col_name_input] = value_input
    # Jika kolom input tidak ada di X.columns (misal job_title_xxx yang tidak ada setelah cleaning),
    # ini akan diabaikan, dan kolom tersebut akan tetap 0 di input_df, yang umumnya OK.

# Handle jika input_data memiliki fitur yang tidak ada di X.columns (mis. karena one-hot encoding spesifik)
# Ini penting jika job_title yang dipilih di input_data tidak ada di X_train setelah cleaning/splitting
# Contoh: 'job_title_Data Scientist' mungkin ada, tapi 'job_title_RareJob' mungkin tidak.
# Cara paling aman adalah memastikan X_train.columns digunakan untuk input_df
# Atau memastikan bahwa one-hot encoding diterapkan secara konsisten.

# Untuk simplicity, kita asumsikan input_data key-nya sudah mewakili kolom yang akan ada di X.
# Jika ada 'job_title_Data Scientist' di input_data, dan X (dari df_dummy) memiliki kolom itu, akan terisi.
# Jika tidak, akan tetap 0, yang mungkin menyebabkan prediksi kurang akurat jika itu fitur penting.

if not X.empty: # Pastikan X tidak kosong
    prediksi_gaji = model.predict(input_df)[0]
    print(f"\nPrediksi gaji baru dalam USD: ${prediksi_gaji:,.2f}")
else:
    print("\nTidak dapat melakukan prediksi gaji baru karena X (fitur) kosong setelah pemrosesan.")

# --- Fungsi untuk menghitung Kenaikan Gaji Year-on-Year (YoY) untuk Random Forest ---
def calculate_yoy_increase_forest(rf_model, base_input_features, current_year, previous_year, all_model_columns):
    """
    Menghitung persentase kenaikan gaji YoY menggunakan model Random Forest.
    Memodifikasi 'work_year' dalam fitur input untuk prediksi tahun ini dan tahun lalu.
    
    Args:
        rf_model: Model Random Forest yang sudah dilatih.
        base_input_features (dict): Fitur input dasar, tidak termasuk 'work_year'. 
                                    'work_year' akan ditambahkan/diperbarui oleh fungsi ini.
        current_year (int): Tahun saat ini untuk prediksi.
        previous_year (int): Tahun sebelumnya untuk prediksi.
        all_model_columns (pd.Index): Kolom yang digunakan saat melatih model (X.columns).
                                      Ini penting untuk memastikan input DataFrame memiliki semua fitur dummy yang benar.

    Returns:
        tuple: (yoy_increase_percentage, salary_current, salary_previous) atau (None, salary_current, salary_previous)
    """
    # Prediksi untuk tahun ini
    input_features_current = base_input_features.copy()
    input_features_current['work_year'] = current_year
    df_current = pd.DataFrame(columns=all_model_columns)
    df_current.loc[0] = 0 # Inisialisasi semua kolom dengan 0
    for col, value in input_features_current.items():
        if col in df_current.columns:
            df_current.at[0, col] = value
    salary_current = rf_model.predict(df_current)[0]
    
    # Prediksi untuk tahun sebelumnya
    input_features_previous = base_input_features.copy()
    input_features_previous['work_year'] = previous_year
    df_previous = pd.DataFrame(columns=all_model_columns)
    df_previous.loc[0] = 0 # Inisialisasi semua kolom dengan 0
    for col, value in input_features_previous.items():
        if col in df_previous.columns:
            df_previous.at[0, col] = value
    salary_previous = rf_model.predict(df_previous)[0]
    
    if salary_previous > 0:
        yoy_increase = ((salary_current - salary_previous) / salary_previous) * 100
        return yoy_increase, salary_current, salary_previous
    else:
        return None, salary_current, salary_previous

# Contoh penggunaan fungsi YoY dengan model Random Forest yang sudah dilatih:
# Pastikan model 'model' (Random Forest) dan 'X.columns' (kolom fitur) sudah ada.

if 'model' in locals() and hasattr(model, 'predict') and 'X' in locals() and hasattr(X, 'columns') and not X.empty:
    # Gunakan fitur dasar dari contoh prediksi yang ada di script, tapi tanpa 'work_year' dan 'employee_residence'
    # Sesuaikan ini dengan fitur yang relevan untuk kasus Anda.
    example_base_features_rf = {
        'remote_ratio': 100,
        'experience_level_SE': 1, # Contoh: Senior Level
        'employment_type_FT': 1,  # Contoh: Full Time
        'job_title_Data Scientist': 1, # Contoh: Data Scientist
        # 'employee_residence_US': 1, # Dihapus
        'company_size_M': 1 # Contoh: Medium Company Size
        # Tambahkan fitur dummy lain yang relevan jika ada, pastikan semua bernilai 0 atau 1
        # dan konsisten dengan kolom di X.columns
    }

    example_current_year_rf = 2023
    example_previous_year_rf = 2022
    
    # Pastikan df_cleaned ada dan memiliki 'work_year'
    if 'df_cleaned' in locals() and 'work_year' in df_cleaned.columns:
        min_year_in_data_rf = df_cleaned['work_year'].min() 
    else:
        # Fallback jika df_cleaned atau work_year tidak ada (seharusnya tidak terjadi)
        min_year_in_data_rf = df['work_year'].min() 

    all_feature_columns = X.columns 

    if example_previous_year_rf >= min_year_in_data_rf:
        yoy_rf, pred_current_rf, pred_previous_rf = calculate_yoy_increase_forest(
            model, 
            example_base_features_rf, 
            example_current_year_rf, 
            example_previous_year_rf, 
            all_feature_columns
        )
        print(f"\n--- Contoh Perhitungan YoY untuk Model Random Forest ({example_previous_year_rf} ke {example_current_year_rf}) ---")
        print(f"Fitur Dasar (tanpa tahun, disesuaikan per tahun): {example_base_features_rf}")
        print(f"Prediksi Gaji Tahun {example_previous_year_rf}: USD {pred_previous_rf:,.2f}")
        print(f"Prediksi Gaji Tahun {example_current_year_rf}: USD {pred_current_rf:,.2f}")
        if yoy_rf is not None:
            print(f"Persentase Kenaikan Gaji YoY: {yoy_rf:.2f}%")
        else:
            print("Tidak dapat menghitung YoY karena prediksi gaji tahun sebelumnya adalah nol atau negatif.")
    else:
        print(f"\nTidak dapat menghitung YoY untuk {example_previous_year_rf} karena data paling awal yang telah dibersihkan adalah {min_year_in_data_rf}.")
else:
    print("\nTidak dapat menjalankan contoh YoY untuk Random Forest karena model, X.columns tidak tersedia/terlatih, atau X kosong.")